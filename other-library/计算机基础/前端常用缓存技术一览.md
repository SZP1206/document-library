@[常用正则表达式集锦](https://github.com/danygitgit/document-library/blob/master/other-library/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%9B%86%E9%94%A6%20.md)  

> create by **db** on **2019-5-13 09:45:24**   
> Recently revised in **2019-6-21 11:30:54**  

&emsp;**Hello 小伙伴们，如果觉得本文还不错，麻烦点个赞或者给个 star，你们的赞和 star 是我前进的动力！[GitHub 地址](https://github.com/danygitgit/document-library/blob/master/other-library/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%9B%86%E9%94%A6%20.md)**  


# 前言  

> I hear and I fogorget.  

> I see and I remember.  

> I do and I understand.  

&emsp;作为一个前端码农，总是避免不了使用正则来检验数据或者截取字符串。然而对于这些“火星文”总是记不牢靠。因此，把工作中常用的一些正则表达式整理存档，给自己留个底，也给朋友们做个参考。

&emsp;此文档不做正则科普详解，仅供查阅。如果不是太清楚正则是啥，烦请移步参考文献。

&emsp;参考文献：

- [前端常用缓存技术 | 博客园-醉盏](https://www.cnblogs.com/belove8013/p/8134067.html)

- [漫话前端缓存 | 谢子琼](http://www.sohu.com/a/288324635_575744)
- [说说几种常用的前端缓存 | CSDN-blank](https://blog.csdn.net/weixin_38639882/article/details/79791786)

# 正文

## 前端缓存一览

&emsp;前端缓存主要分为浏览器缓存和http缓存。大致分类如下图所示：

![](../public-repertory/img/webcache-img/前端缓存分类.png)

## 浏览器的缓存

&emsp;打开谷歌浏览器，按`F12`打开开发者工具，选择`Application`，我们就能看到自己浏览器的缓存了。如下图所示：

![](../public-repertory/img/webcache-img/浏览器缓存.png)

&emsp;该图很清晰的可以看到浏览器的缓存分类，在平时的开发过程中，最常用的缓存主要有cookie，localStage，seeionStage这三种缓存，那么这三种缓存有什么区别呢？

### 1、Cookie

**Cookie使用教程-->[菜鸟教程](https://www.runoob.com/js/js-cookies.html)**

#### 什么是Cookie

&emsp; `JavaScript`是运行在客户端的脚本，因此一般是不能够设置`Session`的，因为`Session`是运行在服务器端的。而`cookie`是运行在客户端的，所以可以用JS来设置`cookie`。

&emsp; `cookie`是浏览器提供的一种机制，它将`document`对象的`cookie`属性提供给`JavaScript`。可以由`JavaScript`对其进行控制，而并不是`JavaScript`本身的性质。cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个`cookie`可用。因此，`cookie`可以跨越一个域名下的多个网页，但不能跨越多个域名使用。 

#### Cookie的优点
`cookie`机制将信息存储于用户硬盘，因此可以作为全局变量，这是它最大的一个优点。它可以用于以下几种场合。 

1. 保存用户登录状态。
2. 跟踪用户行为。
3. 定制页面。
4. 创建购物车，例如淘宝网就使用`cookie`记录了用户曾经浏览过的商品，方便随时进行比较。

#### Cookie的缺点

`cookie`能完成的部分应用，还有更多的功能需要全局变量。`cookie`的缺点主要集中于安全性和隐私保护。主要包括以下几种： 

1. `cookie`可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的`cookie`功能； 
2. `cookie`是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的`cookie`也是不能互相访问的； 
3. `cookie`可能被删除。因为每个`cookie`都是硬盘上的一个文件，因此很有可能被用户删除； 
4. `cookie`安全性不够高。所有的`cookie`都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。

#### 总结

&emsp;cookie是比较老的前端缓存技术了。

&emsp;想要使用它前端必须要有服务（静态网页是不行的），而且存储大小限制在`4kb`。那么为什么必须要有服务才能使用`cookie`呢？因为只要有请求涉及，`cookie`就要在服务器和浏览器之间来回传送。而且由于浏览器的跨域限制，客户端和服务端必须要保证同源的原则才能使用，但是由于cookie是存放在前端的，所以安全问题一直是个大问题。

&emsp;因此一般重要的信息不建议放在cookie中存放。

### 2、localStorage

#### 什么是localstorage？

&emsp;在HTML5中，新加入了一个`localStorage`特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为`4k`)，`localStorage`中一般浏览器支持的是`5M`大小，这个在不同的浏览器中`localStorage`会有所不同。

#### localStorage的优势与局限

**优势**

1.  `localStorage`拓展了cookie的4K限制

2. `localStorage`会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的

**局限**

1. 浏览器的大小不统一，并且在IE8以上的IE版本才支持`localStorage`这个属性

2. 目前所有的浏览器中都会把`localStorage`的值类型限定为`string`类型，这个在对我们日常比较常见的`JSON`对象类型需要一些转换

3.  `localStorage`在浏览器的隐私模式下面是不可读取的

4.  `localStorage`本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡

5. `localStorage`不能被爬虫抓取到

&emsp;`localStorage`与`SessionStorage`的唯一一点区别就是`localStorage`属于永久性存储，而`SessionStorage`属于当会话结束的时候，`SessionStorage`中的键值对会被清空


#### localStorage的使用方法

&emsp;localStorage特点就是“持久” ——一旦通过保存，不通过手动清除的话，就会一直保存在前端。它的保存格式是键值对的方式也就是“key-value”的方式保存的，以下是它的一些使用方法：

```JavaScript
localStorage.length    //获得storage中的个数
localStorage.key(n)    //获得storage中第n个元素对的键值（第一个元素是0）
localStorage.getItem(key)    //获取键值key对应的值
localStorage.key    //获取键值key对应的值
localStorage.setItem(key, value)    //添加数据，键值为key，值为value
localStorage.removeItem(key)    //移除键值为key的数据
localStorage.clear()    //清除所有数据
```

#### localstorage的其他注意事项

&emsp;一般我们会将JSON存入localStorage中，但是在localStorage会自动将localStorage转换成为字符串形式。

&emsp;这个时候我们可以使用`JSON.stringify()`这个方法，来将JSON对象转换成为JSON字符串

示例：
```JavaScript
if(!window.localStorage){
   alert("浏览器支持localstorage");
}else{
   var storage=window.localStorage;
   var data={
      name:'xiecanyong',
      sex:'man',
      hobby:'program'
   };
   //将JSON字对象转换成为JSON字符串输入
   var d = JSON.stringify(data);
   storage.setItem("data",d);
   console.log(storage.data);
}
```
读取之后要将JSON字符串转换成为JSON对象，使用JSON.parse()方法

```JavaScript
var storage=window.localStorage;
   var data={
         name:'xiecanyong',
         sex:'man',
         hobby:'program'
   };
   var d=JSON.stringify(data);
   storage.setItem("data",d);
   //将JSON字符串转换成为JSON对象输出
   var json=storage.getItem("data");
   var jsonObj=JSON.parse(json);
   console.log(typeof jsonObj);
```

### 3、SessionStorage

#### 什么是SessionStorage？

&emsp;`SessionStorage`用于本地存储一个会话（Session）中的数据，它的作用域是窗口级别的，也就是说不同窗口间的sessionStorage数据不能共享的。这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此`SessionStorage`不是一种持久化的本地存储，仅仅是会话级别的存储。

#### SessionStorage的特点

&emsp;这个和`localStorage`有什么区别呢？作为一种会话级别的本地存储，一旦关闭浏览器`SessionStorage`就会消失，而`localStorage`是很“持久”的，即使你关闭一万次浏览器也没事，所以差距还是很大的。因为现在都是前后端分离的开发模式，前端工程师都很青睐这两种前端缓存方式。

#### SessionStorage的基本用法：

```JavaScript
sessionStorage.length    //获得storage中的个数
sessionStorage.key(n)    //获得storage中第n个元素对的键值（第一个元素是0）
sessionStorage.getItem(key)    //获取键值key对应的值
sessionStorage.key    //获取键值key对应的值
sessionStorage.setItem(key, value)    //添加数据，键值为key，值为value
sessionStorage.removeItem(key)    //移除键值为key的数据
sessionStorage.clear()    //清除所有数据
```
<!-- 4.Session
对于服务端的程序眼来说session大家肯定很熟悉了，session是一种服务端的机制，也就是能把信息存放在服务端，所以安全可以保障，它的原理是通过session id来识别客户端，这个session id是存放在cookie中的（当然session id让用户看见没无妨），服务端会通过session id来识别客户端进行匹配和判断。它和cookie对比起来差距就很明显了，一个是把数据存在客户端；一个存在服务端，从安全性考虑的话一般像用户名密码这种私密信息一般放在session中。 -->
<!-- ### 5、ApplicationCache
 
applicationCache是html5新增的一个离线应用功能

•离线浏览: 用户可以在离线状态下浏览网站内容。
•更快的速度: 因为数据被存储在本地，所以速度会更快.
•减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。
在对应用进行缓存的时候需要一个manifest文件， -->

<!-- 02

Http缓存

http缓存包含强制缓存和协商缓存两种：

强制缓存

强制缓存的步骤：

第一次发起请求，服务器返回资源，并在响应报头添加强制缓存参数。
根据缓存参数决定是否将返回资源缓存
第二次发起请求，浏览器根据缓存数据库的有效期决定是否从缓存中拿取，如果缓存有效则返回200状态，反之则再次请求服务器
重复以上步骤
强制缓存的优点：

减少了客户端与服务端之间的请求，降低了流量消耗
加快了页面的响应速度
减少了服务器的访问压力
强制缓存的相关字段：

Expires，cache-control，pragma

Expires是http1.0的字段，表示缓存到期时间（当前时间+缓存有效期）

Expires：Tue, 20 Nov 2018 07:35:04 GMT

该字段采用绝对时间，该字段由服务器返回，并与浏览器时间作对比，判断缓存是否有效，这时会发现，如果时差或者浏览器设置时间与服务器不一致，就会导致缓存无效

cache-control是http1.1的字段，该字段采用相对时间，可以很好地解决Expires的缺点

cache-control:max-age=172800

cache-control还有其他几个常见的取值：

no-store:不缓存，无论何时访问多少次都会直接从服务器拿取数据
no-cache:表面意思是不缓存，实际上会把请求的资源放入缓存中，类似max-age = 0
public:表示客户端和代理服务器都可缓存
private:表示只有客户端可缓存
Pragma是HTTP1.0中的字段，相当于Cache-Control: no-cache，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。主要用于兼容http1.0的客户端。

当Expires和cache-control同时存在时，cache-control的优先级要高于Expires，通常为了兼容http1.0的客户端两组会同时使用

那当开发人员更新了资源发布到服务器后，由于强制缓存有效，因而没有向服务器请求新的资源，从而导致了新发布的内容没有及时的在网页上展示出来。这就是强制缓存所导致的弊端，针对这个问题最常用的解决办法就是在文件名后面加上hash或者版本号（还有一些其他的解决办法，此处不再一一讲解），让浏览器认为是在访问一个新的资源。

协商缓存（对比缓存）

协商缓存是在强制缓存超过有效期时，浏览器拿到缓存中的标识来与服务器做对比，如果缓存依然是最新资源，则返回304状态，如果不是，服务器则返回新的资源，然后再写入缓存。

协商缓存跟强制缓存不相同的是，它会请求服务器，当缓存有效时，返回304状态，返回资源依然从缓存中读取，当缓存不是最新资源时，才会返回响应资源，再次写入缓存。

对比缓存两组字段：

1、Last-Modified和If-Modified-Since

Last-Modified是服务器在第一次响应请求时，告诉浏览器最后修改的时间

If-Modified-Since是当缓存有效期已过时，将缓存中的last-Modidied写入If-Modified-Since，然后再与服务器上的Last-Modified做对比，如果相等则返回304，否则说明资源被改动，重新请求数据

2、Etag和If-None-Match

Etag是被访问资源的特殊标识，它与Last-Modified和If-Modified-Since工作原理大致相同，只是与Last-Modified的赋值不相同，Last-Modified一般采用的是更新时间，而Etag则采用hash(一般采用hash)

那为何有两组字段，因为Last-Modified和If-Modified-Since最低单位是秒，如果在一秒之内更新资源缓存是不会被更新的，而Etag和If-None-Match则解决了上述问题，所以Etag的优先级高于Last-Modified

以上涉及到的都是一些基本的理论知识，若要更进一步的理解前端缓存，还需更多的实践操练。 -->

## 总结  

&emsp;作为一只前端菜鸟，本篇文章旨在记录自己的学习心得，如有不足，还请多多指教。其中大部分是拷贝的，如有错误，慢慢用，慢慢改。谢谢大家。  

&emsp;路漫漫其修远兮，与诸君共勉。  

**后记：Hello 小伙伴们，如果觉得本文还不错，记得点个赞或者给个 star，你们的赞和 star 是我编写更多更丰富文章的动力！[GitHub 地址](https://github.com/danygitgit/document-library/blob/master/other-library/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%9B%86%E9%94%A6%20.md)**  

> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://user-gold-cdn.xitu.io/2018/12/23/167d9537f3e29c99?w=88&h=31&f=png&s=1888" /></a><br /><a xmlns:dct="http://purl.org/dc/terms/" property="dct:title">**db** 的文档库</a> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="db" property="cc:attributionName" rel="cc:attributionURL">db</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br />基于<a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/danygitgit" rel="dct:source">https://github.com/danygitgit</a>上的作品创作。<br />本许可协议授权之外的使用权限可以从 <a xmlns:cc="http://creativecommons.org/ns#" href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="cc:morePermissions">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。  